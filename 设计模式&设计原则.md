# 设计模式&设计原则


## 设计模式

### 设计模式分类
- 创建型：单例模式，抽象工厂模式，构造器模式，工厂模式，原型模式
- 结构型：适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式
- 行为型模：模版方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，责任链模式，访问者模式

设计模式就是对于特定问题符合设计原则的通用解决方案

## 设计原则

### 5大设计原则
- 里式替换原则 LSP
- 依赖倒置原则 DIP
- 接口隔离原则 ISP
- 组合聚合原则 CARP
- 迪米特法则 LOD


#### 开闭原则 OCP
**描述：**  
一个类应该对扩展开发，对修改关闭
实现开闭原则的一个重要基础就是面向接口编程，只有当客户端面向的是接口，扩展新的实现，对客户端的影响才是最小的；

一个需要警惕的地方就是，当出现大量的 if ... else 的时候就应该考虑使用多态来代替条件判断；


#### 里式替换原则 LSP
定义1（官方定义）：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型


**通俗地讲：**
- 所有引用基类的地方必须能透明地使用其子类的对象。
- 子类可以扩展父类的功能，但不要修改父类的功能；
- 子类不要去重写/重载父类已经实现的方法


违反里式替换原则的示例：
``` java
Animal {
	void fly() {
		System.out.println("I can fly");
	}
}

Person extend Animal {
	void fly() {
		throw new Exception("I can't fly");
	}
}

Clien {
	void main() {
		Animal a = new Animal();
		doFly(a);  // 这个是正常的

		Animal a = new Person();
		doFly(a);  // 这里就出现问题了，这就是违反里式替换原则，doFly() 方法可以接收 Animal 对象，却不能接收 Animal 的子类对象
	}

	void doFly(Animal a) {
		a.fly();
	}
}
```
